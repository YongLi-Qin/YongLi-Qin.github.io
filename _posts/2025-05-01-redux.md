---
layout: post
title: "ğŸ“ [Deep Dive] About Redux"
date: 2025-05-01 12:00:00 +1000
---

# ğŸ“ About Redux

Understand What It Is, Why It Matters, and How It Works

---

## âœ… Introduction

Redux provides a **centralized store** to hold all **application state**.  
Instead of each component managing its own **local state** and passing data via **props**,  
Redux allows components to **read** and **update shared global state** in a **consistent and scalable way**.

ğŸ‘‰ For example, the **shopping cart** in an e-commerce website is typically managed with Redux, since it needs to be **accessible and modifiable** from multiple pages like the *product list*, *cart page*, and *checkout*.


---


## ğŸ” Core Concepts

Redux has three main building blocks:

| **Concept** | **Description** |
|-------------|------------------|
| `Store`     | Holds the applicationâ€™s state (like a central database in memory) |
| `Action`    | A plain JavaScript object that describes what happened |
| `Reducer`   | A pure function that determines how state changes in response to an action |


---


## âœ… Why Use Redux?

Redux offers a number of benefits, especially for medium to large-scale applications:

- âœ… **Centralized state management** â€” all application state is stored in a single place, making it easier to access and manage.
- âœ… **Avoid deeply nested props passing** (a.k.a. *"prop drilling"*) â€” no need to pass data through multiple layers of components.
- âœ… **Share state across distant components** â€” such as sharing cart data between the navbar and the checkout page.
- âœ… **Debuggable via Redux DevTools** â€” track every state change over time and replay actions for debugging.
- âœ… **Separate state logic from UI logic** â€” improves code clarity and reusability.
- âœ… **Easy to reason about** â€” the strict unidirectional data flow makes the application behavior more understandable.

---


## ğŸ› ï¸ Redux Workflow in React

Hereâ€™s a typical step-by-step workflow for using Redux in a React application:

1. **Create a Redux store**  
   Use `configureStore()` from Redux Toolkit to initialize the global store that will hold your entire app's state.

2. **Create a slice (module of state)**  
   Use `createSlice()` to define:
   - the initial state
   - reducer functions (how state changes)
   - automatically generated action creators

3. **Provide the store to your app**  
   Wrap your React app with `<Provider store={store}>` so all components can access the Redux store.

4. **Dispatch actions from components**  
   Use `useDispatch()` to trigger an action, like `dispatch(addToCart(product))`.

5. **Reducers handle actions and update the state**  
   Redux automatically calls the corresponding reducer function, which returns a new state.

6. **Components read updated state**  
   Use `useSelector()` to read specific slices of state (e.g., `state.cart.items`). When state changes, components re-render automatically.

7. **(Optional) Use middleware for async logic**  
   Use `redux-thunk` or `redux-saga` if you need to handle side effects like API calls.


---


## ğŸ›’ For Example: Managing a Shopping Cart

In an e-commerce application, the shopping cart is a perfect use case for Redux:

- ğŸ§© Multiple pages (Product List, Cart Page, Checkout Page) all need access to the cart
- ğŸ”„ You want to update cart state from any page
- ğŸš€ You want cart data to persist as users navigate

Redux lets you:

- ğŸ—‚ï¸ Store cart items in a centralized state (`store.cart.items`)
- â• Add to cart using `dispatch(addToCart(product))`
- âŒ Remove or clear cart with dedicated actions like `dispatch(removeFromCart(id))`
- ğŸ‘€ Access cart data anywhere using `useSelector((state) => state.cart.items)`

ğŸ¯ With Redux, your shopping cart logic becomes **cleaner**, **centralized**, and **decoupled** from individual components â€” making your application easier to scale and maintain.

---